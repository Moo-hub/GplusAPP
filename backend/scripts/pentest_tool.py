#!/usr/bin/env python
"""
Security Audit Tool for GPlus Recycling App - Penetration Testing Extension
This script provides additional penetration testing capabilities for the
security audit tool to test the application for vulnerabilities.

Usage:
  python pentest_tool.py --target http://localhost:8000 --scope [all|api|web|auth]
"""

import os
import sys
import json
import subprocess
import argparse
import datetime
import re
import requests
import urllib3
from pathlib import Path
from typing import Dict, List, Any, Optional, Tuple
from concurrent.futures import ThreadPoolExecutor

# Disable SSL warnings for testing
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

# Configure paths
SCRIPT_DIR = Path(__file__).parent
PROJECT_ROOT = SCRIPT_DIR.parent.parent
REPORT_DIR = PROJECT_ROOT / "security_reports"


class PenetrationTestTool:
    def __init__(self, target_url: str, report_dir: Path = REPORT_DIR, verbose: bool = False):
        """Initialize the penetration testing tool"""
        self.target_url = target_url.rstrip('/')
        self.report_dir = report_dir
        self.verbose = verbose
        self.timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
        self.report_data = {
            "timestamp": datetime.datetime.now().isoformat(),
            "target": target_url,
            "summary": {
                "vulnerabilities": {
                    "critical": 0,
                    "high": 0,
                    "medium": 0,
                    "low": 0,
                    "info": 0
                },
                "endpoints_tested": 0,
                "vulnerable_endpoints": 0,
                "security_issues": []
            },
            "api_tests": {},
            "web_tests": {},
            "auth_tests": {}
        }
        
        # Create report directory if it doesn't exist
        if not self.report_dir.exists():
            self.report_dir.mkdir(parents=True)
        
        # Common headers for requests
        self.headers = {
            'User-Agent': 'GPlus-Security-Audit-Tool/1.0',
            'Accept': 'application/json',
            'Content-Type': 'application/json'
        }
        
        # Session for persistent connections
        self.session = requests.Session()
    
    def run_pentest(self, scope: str = "all"):
        """Run penetration tests with the specified scope"""
        print(f"\n{'=' * 80}")
        print(f"Starting Penetration Tests (Scope: {scope})")
        print(f"Target: {self.target_url}")
        print(f"{'=' * 80}")
        
        # Check if target is reachable
        try:
            response = self.session.get(
                f"{self.target_url}/",
                headers=self.headers,
                timeout=10,
                verify=False
            )
            print(f"  [✓] Target is reachable (Status: {response.status_code})")
        except requests.exceptions.RequestException as e:
            print(f"  [!] Target is not reachable: {e}")
            print(f"  [!] Make sure the application is running and the URL is correct")
            print(f"  [!] Continuing with tests anyway...")
        
        if scope in ("all", "api"):
            self._test_api_security()
        
        if scope in ("all", "web"):
            self._test_web_security()
        
        if scope in ("all", "auth"):
            self._test_auth_security()
        
        self._generate_report()
        
        print(f"\n{'=' * 80}")
        print(f"Penetration Tests Completed")
        print(f"Report saved to: {self.report_dir / f'pentest_{self.timestamp}.json'}")
        print(f"Summary saved to: {self.report_dir / f'pentest_{self.timestamp}.md'}")
        print(f"{'=' * 80}\n")
        
        # Print summary
        self._print_summary()
    
    def _test_api_security(self):
        """Test API endpoints for security vulnerabilities"""
        print("\n[+] Testing API Security...")
        
        # Common API endpoints to test
        endpoints = self._discover_api_endpoints()
        
        # Track findings
        findings = []
        endpoints_tested = 0
        
        # Test each endpoint
        for endpoint in endpoints:
            endpoints_tested += 1
            endpoint_findings = []
            
            # OWASP API Security Top 10 Tests
            
            # API1:2019 - Broken Object Level Authorization
            self._test_broken_object_level_auth(endpoint, endpoint_findings)
            
            # API2:2019 - Broken User Authentication
            self._test_broken_authentication(endpoint, endpoint_findings)
            
            # API3:2019 - Excessive Data Exposure
            self._test_excessive_data_exposure(endpoint, endpoint_findings)
            
            # API4:2019 - Lack of Resources & Rate Limiting
            self._test_rate_limiting(endpoint, endpoint_findings)
            
            # API5:2019 - Broken Function Level Authorization
            self._test_broken_function_level_auth(endpoint, endpoint_findings)
            
            # API6:2019 - Mass Assignment
            self._test_mass_assignment(endpoint, endpoint_findings)
            
            # API7:2019 - Security Misconfiguration
            self._test_security_misconfiguration(endpoint, endpoint_findings)
            
            # API8:2019 - Injection
            self._test_injection(endpoint, endpoint_findings)
            
            # API9:2019 - Improper Assets Management
            self._test_improper_assets_management(endpoint, endpoint_findings)
            
            # API10:2019 - Insufficient Logging & Monitoring
            # (Cannot be tested directly, skipping)
            
            if endpoint_findings:
                findings.extend(endpoint_findings)
                self.report_data["summary"]["vulnerable_endpoints"] += 1
        
        # Add findings to report
        for finding in findings:
            self.report_data["summary"]["vulnerabilities"][finding["severity"]] += 1
            
            # Add to summary issues
            if finding["severity"] in ("critical", "high"):
                self.report_data["summary"]["security_issues"].append(
                    f"[{finding['severity'].upper()}] {finding['title']} at {finding['endpoint']}"
                )
        
        # Store in report
        self.report_data["api_tests"] = {
            "endpoints_tested": endpoints_tested,
            "findings": findings
        }
        
        self.report_data["summary"]["endpoints_tested"] += endpoints_tested
        
        print(f"  [✓] Tested {endpoints_tested} API endpoints")
        if findings:
            print(f"  [!] Found {len(findings)} potential API security issues")
    
    def _test_web_security(self):
        """Test web application for security vulnerabilities"""
        print("\n[+] Testing Web Security...")
        
        # Track findings
        findings = []
        
        # OWASP Top 10 Tests
        
        # A1:2021 - Broken Access Control
        self._test_broken_access_control(findings)
        
        # A2:2021 - Cryptographic Failures
        self._test_cryptographic_failures(findings)
        
        # A3:2021 - Injection
        self._test_web_injection(findings)
        
        # A4:2021 - Insecure Design
        # (Cannot be tested directly, skipping)
        
        # A5:2021 - Security Misconfiguration
        self._test_web_security_misconfiguration(findings)
        
        # A6:2021 - Vulnerable and Outdated Components
        # (Covered by dependency scan, skipping)
        
        # A7:2021 - Identification and Authentication Failures
        self._test_authentication_failures(findings)
        
        # A8:2021 - Software and Data Integrity Failures
        self._test_integrity_failures(findings)
        
        # A9:2021 - Security Logging and Monitoring Failures
        # (Cannot be tested directly, skipping)
        
        # A10:2021 - Server-Side Request Forgery (SSRF)
        self._test_ssrf(findings)
        
        # Add findings to report
        for finding in findings:
            self.report_data["summary"]["vulnerabilities"][finding["severity"]] += 1
            
            # Add to summary issues
            if finding["severity"] in ("critical", "high"):
                self.report_data["summary"]["security_issues"].append(
                    f"[{finding['severity'].upper()}] {finding['title']} at {finding.get('endpoint', 'web application')}"
                )
        
        # Store in report
        self.report_data["web_tests"] = {
            "findings": findings
        }
        
        print(f"  [✓] Performed web security tests")
        if findings:
            print(f"  [!] Found {len(findings)} potential web security issues")
    
    def _test_auth_security(self):
        """Test authentication and authorization security"""
        print("\n[+] Testing Authentication & Authorization Security...")
        
        # Common auth endpoints
        auth_endpoints = [
            "/api/auth/login",
            "/api/auth/register",
            "/api/auth/refresh",
            "/api/users/me",
            "/login",
            "/register",
            "/api/v1/auth/login",
            "/api/v1/auth/register"
        ]
        
        # Track findings
        findings = []
        endpoints_tested = 0
        
        for endpoint in auth_endpoints:
            full_url = f"{self.target_url}{endpoint}"
            try:
                response = self.session.head(full_url, headers=self.headers, timeout=5, verify=False)
                if response.status_code < 500:  # Consider 404s as valid for security testing
                    endpoints_tested += 1
                    
                    # Test for common auth vulnerabilities
                    
                    # Brute Force Protection
                    self._test_brute_force_protection(endpoint, findings)
                    
                    # Password Policy
                    self._test_password_policy(endpoint, findings)
                    
                    # Account Lockout
                    self._test_account_lockout(endpoint, findings)
                    
                    # Token Handling
                    self._test_token_handling(endpoint, findings)
                    
                    # Multi-factor Authentication
                    self._test_mfa_support(endpoint, findings)
            except requests.exceptions.RequestException:
                continue
        
        # Add findings to report
        for finding in findings:
            self.report_data["summary"]["vulnerabilities"][finding["severity"]] += 1
            
            # Add to summary issues
            if finding["severity"] in ("critical", "high"):
                self.report_data["summary"]["security_issues"].append(
                    f"[{finding['severity'].upper()}] {finding['title']} at {finding.get('endpoint', 'authentication system')}"
                )
        
        # Store in report
        self.report_data["auth_tests"] = {
            "endpoints_tested": endpoints_tested,
            "findings": findings
        }
        
        self.report_data["summary"]["endpoints_tested"] += endpoints_tested
        
        print(f"  [✓] Tested {endpoints_tested} authentication endpoints")
        if findings:
            print(f"  [!] Found {len(findings)} potential authentication security issues")
    
    def _discover_api_endpoints(self) -> List[str]:
        """Discover API endpoints from documentation or API exploration"""
        print("  [*] Discovering API endpoints...")
        
        # Common API paths to check
        common_paths = [
            "/api",
            "/api/v1",
            "/api/v2",
            "/api/users",
            "/api/products",
            "/api/items",
            "/api/auth",
            "/api/data",
            "/api/recycling",
            "/api/collections"
        ]
        
        # Common endpoint patterns for RESTful APIs
        endpoint_patterns = [
            "",  # Base endpoint
            "/{id}",
            "/create",
            "/update",
            "/delete",
            "/search",
            "/filter",
            "/all"
        ]
        
        discovered_endpoints = []
        
        # Try to find API documentation (Swagger/OpenAPI)
        swagger_paths = [
            "/swagger",
            "/api-docs",
            "/swagger-ui",
            "/swagger-ui.html",
            "/swagger/index.html",
            "/api/swagger",
            "/openapi.json",
            "/swagger.json"
        ]
        
        for path in swagger_paths:
            try:
                response = self.session.get(
                    f"{self.target_url}{path}",
                    headers=self.headers,
                    timeout=5,
                    verify=False
                )
                if response.status_code == 200:
                    print(f"  [✓] Found API documentation at {path}")
                    try:
                        # Try to parse as JSON
                        api_docs = response.json()
                        
                        # Extract endpoints from OpenAPI/Swagger documentation
                        if "paths" in api_docs:
                            for path, _ in api_docs["paths"].items():
                                discovered_endpoints.append(path)
                            print(f"  [✓] Extracted {len(discovered_endpoints)} endpoints from API documentation")
                            return discovered_endpoints
                    except (json.JSONDecodeError, AttributeError):
                        # Not a JSON response, might be HTML
                        pass
            except requests.exceptions.RequestException:
                continue
        
        # If no documentation found, check common endpoints
        print("  [*] No API documentation found, checking common endpoints...")
        
        # Check common API paths and patterns
        for base_path in common_paths:
            for pattern in endpoint_patterns:
                endpoint = f"{base_path}{pattern}"
                try:
                    response = self.session.head(
                        f"{self.target_url}{endpoint}",
                        headers=self.headers,
                        timeout=5,
                        verify=False
                    )
                    if response.status_code < 500:  # Consider 404s as valid for discovery
                        discovered_endpoints.append(endpoint)
                except requests.exceptions.RequestException:
                    continue
        
        print(f"  [✓] Discovered {len(discovered_endpoints)} potential API endpoints")
        return discovered_endpoints
    
    # API Security Test Methods
    
    def _test_broken_object_level_auth(self, endpoint: str, findings: List[Dict[str, Any]]):
        """Test for broken object level authorization (API1:2019)"""
        if not endpoint.endswith(("/{id}", "/{uuid}", "/{user_id}")):
            return
        
        # Extract base endpoint and replace {id} with a test ID
        base_endpoint = endpoint.split("/{")[0]
        test_id = "1"  # Test with ID 1
        test_endpoint = f"{base_endpoint}/{test_id}"
        
        # Try to access the resource without authentication
        try:
            response = self.session.get(
                f"{self.target_url}{test_endpoint}",
                headers=self.headers,
                timeout=5,
                verify=False
            )
            
            # If successful response with data, might be an issue
            if response.status_code == 200:
                try:
                    response_data = response.json()
                    if response_data and not isinstance(response_data, str):
                        findings.append({
                            "title": "Potential Broken Object Level Authorization",
                            "endpoint": test_endpoint,
                            "description": "Endpoint returns data without proper authentication or authorization",
                            "severity": "high",
                            "status_code": response.status_code
                        })
                except (json.JSONDecodeError, AttributeError):
                    pass
        except requests.exceptions.RequestException:
            pass
    
    def _test_broken_authentication(self, endpoint: str, findings: List[Dict[str, Any]]):
        """Test for broken authentication (API2:2019)"""
        if not any(auth_path in endpoint for auth_path in ["/auth", "/login", "/token", "/jwt"]):
            return
        
        # Test for insecure authentication practices
        try:
            # Check for HTTP (non-HTTPS)
            if self.target_url.startswith("http:"):
                findings.append({
                    "title": "Authentication Over Unencrypted HTTP",
                    "endpoint": endpoint,
                    "description": "Authentication endpoints should use HTTPS to protect credentials",
                    "severity": "high"
                })
            
            # Test for token exposure in URL
            response = self.session.get(
                f"{self.target_url}{endpoint}?token=test",
                headers=self.headers,
                timeout=5,
                verify=False
            )
            
            # If endpoint responds differently to token in URL, might accept it
            if response.status_code in [200, 401, 403]:
                findings.append({
                    "title": "Potential Token Exposure in URL",
                    "endpoint": endpoint,
                    "description": "Endpoint may accept authentication tokens in URL query parameters, which can be logged in server logs and browser history",
                    "severity": "medium",
                    "status_code": response.status_code
                })
        except requests.exceptions.RequestException:
            pass
    
    def _test_excessive_data_exposure(self, endpoint: str, findings: List[Dict[str, Any]]):
        """Test for excessive data exposure (API3:2019)"""
        if any(x in endpoint for x in ["/admin", "/internal", "/private"]):
            return  # Skip admin/internal endpoints
        
        try:
            response = self.session.get(
                f"{self.target_url}{endpoint}",
                headers=self.headers,
                timeout=5,
                verify=False
            )
            
            # Check response for potential sensitive data
            if response.status_code == 200:
                try:
                    response_data = response.json()
                    if isinstance(response_data, (dict, list)):
                        sensitive_fields = ["password", "token", "secret", "key", "ssn", "credit_card", "dob", "birthdate"]
                        sensitive_patterns = [
                            r"\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}\b",  # Email
                            r"\b\d{3}-\d{2}-\d{4}\b",  # SSN
                            r"\b\d{4}-\d{4}-\d{4}-\d{4}\b",  # Credit card
                            r"\b\d{16}\b"  # Credit card without dashes
                        ]
                        
                        # Convert to string to search for patterns
                        data_str = json.dumps(response_data)
                        
                        # Check for sensitive fields
                        exposed_fields = []
                        for field in sensitive_fields:
                            if f'"{field}"' in data_str.lower():
                                exposed_fields.append(field)
                        
                        # Check for sensitive patterns
                        for pattern in sensitive_patterns:
                            if re.search(pattern, data_str):
                                exposed_fields.append(f"pattern:{pattern}")
                        
                        if exposed_fields:
                            findings.append({
                                "title": "Potential Excessive Data Exposure",
                                "endpoint": endpoint,
                                "description": f"Endpoint may expose sensitive data: {', '.join(exposed_fields)}",
                                "severity": "medium",
                                "exposed_fields": exposed_fields
                            })
                except (json.JSONDecodeError, AttributeError):
                    pass
        except requests.exceptions.RequestException:
            pass
    
    def _test_rate_limiting(self, endpoint: str, findings: List[Dict[str, Any]]):
        """Test for lack of resources & rate limiting (API4:2019)"""
        if not any(auth_path in endpoint for auth_path in ["/auth", "/login", "/register", "/reset"]):
            return
        
        try:
            # Send multiple requests in quick succession
            request_count = 10
            responses = []
            
            for _ in range(request_count):
                try:
                    response = self.session.get(
                        f"{self.target_url}{endpoint}",
                        headers=self.headers,
                        timeout=2,
                        verify=False
                    )
                    responses.append(response.status_code)
                except requests.exceptions.RequestException:
                    break
            
            # Check if all requests were successful (no rate limiting)
            if len(responses) == request_count and all(code < 429 for code in responses):
                findings.append({
                    "title": "Potential Lack of Rate Limiting",
                    "endpoint": endpoint,
                    "description": f"Endpoint allowed {request_count} consecutive requests without rate limiting",
                    "severity": "medium",
                    "request_count": request_count
                })
        except Exception:
            pass
    
    def _test_broken_function_level_auth(self, endpoint: str, findings: List[Dict[str, Any]]):
        """Test for broken function level authorization (API5:2019)"""
        if any(x in endpoint for x in ["/public", "/docs", "/swagger"]):
            return  # Skip public/docs endpoints
        
        # Extract HTTP methods to test based on endpoint
        methods_to_test = ["GET"]
        if any(x in endpoint for x in ["/admin", "/manage", "/create", "/update", "/delete"]):
            methods_to_test.extend(["POST", "PUT", "DELETE"])
        
        for method in methods_to_test:
            try:
                response = self.session.request(
                    method,
                    f"{self.target_url}{endpoint}",
                    headers=self.headers,
                    timeout=5,
                    verify=False
                )
                
                # Check if admin/privileged endpoint responds with data instead of auth error
                if method != "GET" and response.status_code not in [401, 403, 404, 405]:
                    findings.append({
                        "title": "Potential Broken Function Level Authorization",
                        "endpoint": endpoint,
                        "description": f"{method} request to potentially privileged endpoint did not return an authentication/authorization error",
                        "severity": "high",
                        "method": method,
                        "status_code": response.status_code
                    })
            except requests.exceptions.RequestException:
                continue
    
    def _test_mass_assignment(self, endpoint: str, findings: List[Dict[str, Any]]):
        """Test for mass assignment vulnerability (API6:2019)"""
        if not any(x in endpoint for x in ["/create", "/update", "/register", "/profile"]):
            return
        
        try:
            # Try to update with privileged field
            privileged_fields = {
                "admin": True,
                "role": "admin",
                "isAdmin": True,
                "permissions": ["admin"],
                "userType": "admin"
            }
            
            response = self.session.post(
                f"{self.target_url}{endpoint}",
                json=privileged_fields,
                headers=self.headers,
                timeout=5,
                verify=False
            )
            
            # If successful response, might be vulnerable
            if response.status_code in [200, 201, 202]:
                try:
                    response_data = response.json()
                    if response_data and not isinstance(response_data, str):
                        # Check if any privileged field appears in response
                        data_str = json.dumps(response_data).lower()
                        if any(field.lower() in data_str for field in privileged_fields.keys()):
                            findings.append({
                                "title": "Potential Mass Assignment Vulnerability",
                                "endpoint": endpoint,
                                "description": "Endpoint may allow setting privileged fields",
                                "severity": "high",
                                "status_code": response.status_code
                            })
                except (json.JSONDecodeError, AttributeError):
                    pass
        except requests.exceptions.RequestException:
            pass
    
    def _test_security_misconfiguration(self, endpoint: str, findings: List[Dict[str, Any]]):
        """Test for security misconfiguration (API7:2019)"""
        try:
            # Check for CORS misconfiguration
            headers = {
                **self.headers,
                'Origin': 'https://evil-site.com'
            }
            
            response = self.session.options(
                f"{self.target_url}{endpoint}",
                headers=headers,
                timeout=5,
                verify=False
            )
            
            cors_header = response.headers.get('Access-Control-Allow-Origin')
            if cors_header == '*' or cors_header == 'https://evil-site.com':
                findings.append({
                    "title": "CORS Misconfiguration",
                    "endpoint": endpoint,
                    "description": f"Endpoint has overly permissive CORS policy: {cors_header}",
                    "severity": "medium",
                    "cors_header": cors_header
                })
            
            # Check for information disclosure in error messages
            error_trigger_params = {"error": "''", "id": "undefined", "throw": "error"}
            try:
                response = self.session.get(
                    f"{self.target_url}{endpoint}",
                    params=error_trigger_params,
                    headers=self.headers,
                    timeout=5,
                    verify=False
                )
                
                # Check for verbose error messages
                if response.status_code >= 500:
                    response_text = response.text.lower()
                    error_indicators = ["exception", "stacktrace", "syntax error", "at line", "traceback"]
                    
                    if any(indicator in response_text for indicator in error_indicators):
                        findings.append({
                            "title": "Verbose Error Messages",
                            "endpoint": endpoint,
                            "description": "Endpoint returns detailed error information that could help attackers",
                            "severity": "medium",
                            "status_code": response.status_code
                        })
            except requests.exceptions.RequestException:
                pass
        except requests.exceptions.RequestException:
            pass
    
    def _test_injection(self, endpoint: str, findings: List[Dict[str, Any]]):
        """Test for injection vulnerabilities (API8:2019)"""
        # SQL injection payloads
        sql_payloads = [
            "' OR '1'='1",
            "'; SELECT * FROM users; --",
            "' UNION SELECT 1,2,3 --"
        ]
        
        # NoSQL injection payloads
        nosql_payloads = [
            '{"$gt": ""}',
            '{"$ne": null}'
        ]
        
        # Command injection payloads
        cmd_payloads = [
            "& echo vulnerable",
            "| cat /etc/passwd",
            "; ls -la"
        ]
        
        try:
            # Test GET parameters
            for payload in sql_payloads + nosql_payloads:
                try:
                    response = self.session.get(
                        f"{self.target_url}{endpoint}",
                        params={"q": payload, "search": payload, "id": payload},
                        headers=self.headers,
                        timeout=5,
                        verify=False
                    )
                    
                    # Check for error messages indicating SQL injection
                    if response.status_code >= 500:
                        response_text = response.text.lower()
                        sql_errors = ["sql syntax", "mysql error", "postgresql error", "sqlite error", "database error"]
                        
                        if any(error in response_text for error in sql_errors):
                            findings.append({
                                "title": "Potential SQL Injection",
                                "endpoint": endpoint,
                                "description": "Endpoint may be vulnerable to SQL injection",
                                "severity": "critical",
                                "payload": payload,
                                "status_code": response.status_code
                            })
                            break
                except requests.exceptions.RequestException:
                    continue
            
            # Test POST parameters
            for payload in sql_payloads + nosql_payloads + cmd_payloads:
                try:
                    response = self.session.post(
                        f"{self.target_url}{endpoint}",
                        json={"q": payload, "search": payload, "command": payload, "input": payload},
                        headers=self.headers,
                        timeout=5,
                        verify=False
                    )
                    
                    # Check for unusual success responses or specific error messages
                    if response.status_code == 200 or response.status_code >= 500:
                        response_text = response.text.lower()
                        injection_indicators = [
                            "sql syntax", "mysql error", "postgresql error", 
                            "mongodb", "database error", "command not found", 
                            "permission denied", "/etc/passwd", "vulnerable"
                        ]
                        
                        if any(indicator in response_text for indicator in injection_indicators):
                            findings.append({
                                "title": "Potential Injection Vulnerability",
                                "endpoint": endpoint,
                                "description": "Endpoint may be vulnerable to injection attacks",
                                "severity": "critical",
                                "payload": payload,
                                "status_code": response.status_code
                            })
                            break
                except requests.exceptions.RequestException:
                    continue
        except Exception:
            pass
    
    def _test_improper_assets_management(self, endpoint: str, findings: List[Dict[str, Any]]):
        """Test for improper assets management (API9:2019)"""
        # Check for non-production endpoints that may be accessible
        test_versions = [
            endpoint.replace("/v1/", "/v2/"),
            endpoint.replace("/v2/", "/v1/"),
            endpoint.replace("/api/", "/api/dev/"),
            endpoint.replace("/api/", "/api/test/"),
            endpoint.replace("/api/", "/api/staging/"),
            endpoint.replace("/api/v1/", "/api/v0/"),
            endpoint.replace("/api/v1/", "/api/v1-beta/")
        ]
        
        for test_endpoint in test_versions:
            if test_endpoint == endpoint:
                continue  # Skip if it's the same endpoint
                
            try:
                response = self.session.get(
                    f"{self.target_url}{test_endpoint}",
                    headers=self.headers,
                    timeout=5,
                    verify=False
                )
                
                # If we get a valid response from a dev/test endpoint
                if response.status_code == 200:
                    try:
                        # Check if it returns valid data
                        response_data = response.json()
                        if response_data and not isinstance(response_data, str):
                            findings.append({
                                "title": "Non-Production API Endpoint Exposed",
                                "endpoint": test_endpoint,
                                "description": "Potentially non-production API endpoint is publicly accessible",
                                "severity": "medium",
                                "status_code": response.status_code
                            })
                    except (json.JSONDecodeError, AttributeError):
                        pass
            except requests.exceptions.RequestException:
                continue
    
    # Web Security Test Methods
    
    def _test_broken_access_control(self, findings: List[Dict[str, Any]]):
        """Test for broken access control (A1:2021)"""
        # Common sensitive endpoints that should require authentication
        sensitive_paths = [
            "/admin",
            "/dashboard",
            "/profile",
            "/settings",
            "/users",
            "/api/users",
            "/api/admin",
            "/manage",
            "/console"
        ]
        
        for path in sensitive_paths:
            try:
                response = self.session.get(
                    f"{self.target_url}{path}",
                    headers=self.headers,
                    timeout=5,
                    verify=False
                )
                
                # If successful response with data, might be an issue
                if response.status_code == 200:
                    if "text/html" in response.headers.get("Content-Type", ""):
                        # Check if it looks like an admin/dashboard page
                        response_text = response.text.lower()
                        admin_indicators = ["admin", "dashboard", "management", "settings", "profile", "users", "controls"]
                        
                        if any(indicator in response_text for indicator in admin_indicators):
                            findings.append({
                                "title": "Potential Broken Access Control",
                                "endpoint": path,
                                "description": "Sensitive endpoint accessible without authentication",
                                "severity": "high",
                                "status_code": response.status_code
                            })
                    elif "application/json" in response.headers.get("Content-Type", ""):
                        try:
                            response_data = response.json()
                            if response_data and not isinstance(response_data, str):
                                findings.append({
                                    "title": "Potential Broken Access Control",
                                    "endpoint": path,
                                    "description": "Sensitive API endpoint returns data without authentication",
                                    "severity": "high",
                                    "status_code": response.status_code
                                })
                        except (json.JSONDecodeError, AttributeError):
                            pass
            except requests.exceptions.RequestException:
                continue
    
    def _test_cryptographic_failures(self, findings: List[Dict[str, Any]]):
        """Test for cryptographic failures (A2:2021)"""
        # Test for HTTP (non-HTTPS) usage
        if self.target_url.startswith("http:"):
            findings.append({
                "title": "Insecure HTTP Protocol",
                "endpoint": "/",
                "description": "Application uses unencrypted HTTP instead of HTTPS",
                "severity": "high"
            })
        
        # Check security headers
        try:
            response = self.session.get(
                f"{self.target_url}/",
                headers=self.headers,
                timeout=5,
                verify=False
            )
            
            # Check for important security headers
            security_headers = {
                "Strict-Transport-Security": "Missing HSTS header",
                "Content-Security-Policy": "Missing CSP header",
                "X-Content-Type-Options": "Missing X-Content-Type-Options header",
                "X-Frame-Options": "Missing X-Frame-Options header"
            }
            
            for header, message in security_headers.items():
                if header not in response.headers:
                    findings.append({
                        "title": "Missing Security Header",
                        "endpoint": "/",
                        "description": message,
                        "severity": "medium",
                        "header": header
                    })
        except requests.exceptions.RequestException:
            pass
    
    def _test_web_injection(self, findings: List[Dict[str, Any]]):
        """Test for web injection vulnerabilities (A3:2021)"""
        # Common endpoints to test
        test_endpoints = [
            "/search",
            "/login",
            "/register",
            "/contact",
            "/feedback"
        ]
        
        # Test payloads
        xss_payloads = [
            "<script>alert(1)</script>",
            "\"><script>alert(1)</script>",
            "javascript:alert(1)"
        ]
        
        for endpoint in test_endpoints:
            for payload in xss_payloads:
                try:
                    response = self.session.get(
                        f"{self.target_url}{endpoint}",
                        params={"q": payload, "search": payload, "query": payload},
                        headers=self.headers,
                        timeout=5,
                        verify=False
                    )
                    
                    # Check if the payload is reflected in the response
                    if response.status_code == 200 and "text/html" in response.headers.get("Content-Type", ""):
                        if payload in response.text:
                            findings.append({
                                "title": "Potential Cross-Site Scripting (XSS)",
                                "endpoint": endpoint,
                                "description": "User input is reflected in the response without proper encoding",
                                "severity": "high",
                                "payload": payload
                            })
                            break  # Found vulnerability, stop testing this endpoint
                except requests.exceptions.RequestException:
                    continue
    
    def _test_web_security_misconfiguration(self, findings: List[Dict[str, Any]]):
        """Test for security misconfigurations (A5:2021)"""
        # Common sensitive files that shouldn't be accessible
        sensitive_files = [
            "/.git/HEAD",
            "/.env",
            "/config.json",
            "/config.js",
            "/webpack.config.js",
            "/package-lock.json",
            "/node_modules/",
            "/__pycache__/",
            "/phpinfo.php"
        ]
        
        for file_path in sensitive_files:
            try:
                response = self.session.get(
                    f"{self.target_url}{file_path}",
                    headers=self.headers,
                    timeout=5,
                    verify=False
                )
                
                # Check if file is accessible
                if response.status_code == 200:
                    findings.append({
                        "title": "Sensitive File Exposure",
                        "endpoint": file_path,
                        "description": f"Sensitive file is publicly accessible",
                        "severity": "high",
                        "status_code": response.status_code
                    })
            except requests.exceptions.RequestException:
                continue
        
        # Check for directory listing
        common_dirs = [
            "/uploads",
            "/images",
            "/assets",
            "/static",
            "/files",
            "/backup",
            "/logs"
        ]
        
        for dir_path in common_dirs:
            try:
                response = self.session.get(
                    f"{self.target_url}{dir_path}",
                    headers=self.headers,
                    timeout=5,
                    verify=False
                )
                
                # Check for directory listing
                if response.status_code == 200 and "text/html" in response.headers.get("Content-Type", ""):
                    response_text = response.text.lower()
                    if ("index of" in response_text and "directory listing" in response_text) or \
                       ("parent directory" in response_text and ("size" in response_text or "modified" in response_text)):
                        findings.append({
                            "title": "Directory Listing Enabled",
                            "endpoint": dir_path,
                            "description": "Directory listing is enabled, which can expose sensitive files",
                            "severity": "medium",
                            "status_code": response.status_code
                        })
            except requests.exceptions.RequestException:
                continue
    
    def _test_authentication_failures(self, findings: List[Dict[str, Any]]):
        """Test for identification and authentication failures (A7:2021)"""
        # Common login endpoints
        login_endpoints = [
            "/login",
            "/signin",
            "/auth/login",
            "/api/auth/login",
            "/api/login"
        ]
        
        for endpoint in login_endpoints:
            # Check if endpoint exists
            try:
                response = self.session.head(
                    f"{self.target_url}{endpoint}",
                    headers=self.headers,
                    timeout=5,
                    verify=False
                )
                
                if response.status_code < 500:  # Endpoint exists
                    # Test for default credentials
                    default_credentials = [
                        {"username": "admin", "password": "admin"},
                        {"username": "admin", "password": "password"},
                        {"username": "test", "password": "test"},
                        {"username": "user", "password": "user"}
                    ]
                    
                    for creds in default_credentials:
                        try:
                            response = self.session.post(
                                f"{self.target_url}{endpoint}",
                                json=creds,
                                headers=self.headers,
                                timeout=5,
                                verify=False
                            )
                            
                            # Check if login appears successful
                            if response.status_code == 200:
                                # Look for success indicators
                                try:
                                    response_data = response.json()
                                    if isinstance(response_data, dict) and any(k in response_data for k in ["token", "access_token", "jwt", "success"]):
                                        findings.append({
                                            "title": "Default Credentials Accepted",
                                            "endpoint": endpoint,
                                            "description": f"Application accepts default credentials: {creds['username']}:{creds['password']}",
                                            "severity": "critical",
                                            "status_code": response.status_code
                                        })
                                        break
                                except (json.JSONDecodeError, AttributeError):
                                    if "cookie" in response.headers.get("Set-Cookie", "").lower():
                                        findings.append({
                                            "title": "Default Credentials Accepted",
                                            "endpoint": endpoint,
                                            "description": f"Application accepts default credentials: {creds['username']}:{creds['password']}",
                                            "severity": "critical",
                                            "status_code": response.status_code
                                        })
                                        break
                        except requests.exceptions.RequestException:
                            continue
            except requests.exceptions.RequestException:
                continue
    
    def _test_integrity_failures(self, findings: List[Dict[str, Any]]):
        """Test for software and data integrity failures (A8:2021)"""
        # Check for integrity verification of resources
        try:
            response = self.session.get(
                f"{self.target_url}/",
                headers=self.headers,
                timeout=5,
                verify=False
            )
            
            if response.status_code == 200 and "text/html" in response.headers.get("Content-Type", ""):
                response_text = response.text
                
                # Check for subresource integrity (SRI)
                if "integrity=" not in response_text and ("<script" in response_text or "<link" in response_text):
                    findings.append({
                        "title": "Missing Subresource Integrity",
                        "endpoint": "/",
                        "description": "Application does not use Subresource Integrity (SRI) for external scripts/stylesheets",
                        "severity": "medium"
                    })
        except requests.exceptions.RequestException:
            pass
    
    def _test_ssrf(self, findings: List[Dict[str, Any]]):
        """Test for Server-Side Request Forgery (A10:2021)"""
        # Common SSRF-vulnerable endpoints
        ssrf_endpoints = [
            "/api/fetch",
            "/api/proxy",
            "/api/import",
            "/api/load",
            "/api/file",
            "/api/url"
        ]
        
        # SSRF test URLs
        ssrf_urls = [
            "http://localhost",
            "http://127.0.0.1",
            "http://169.254.169.254",  # AWS metadata
            "http://[::1]"
        ]
        
        for endpoint in ssrf_endpoints:
            for url in ssrf_urls:
                try:
                    response = self.session.post(
                        f"{self.target_url}{endpoint}",
                        json={"url": url},
                        headers=self.headers,
                        timeout=5,
                        verify=False
                    )
                    
                    # Check if successful response with data
                    if response.status_code == 200:
                        try:
                            response_data = response.json()
                            if response_data and not isinstance(response_data, str):
                                findings.append({
                                    "title": "Potential SSRF Vulnerability",
                                    "endpoint": endpoint,
                                    "description": f"Endpoint may be vulnerable to SSRF attacks",
                                    "severity": "high",
                                    "test_url": url,
                                    "status_code": response.status_code
                                })
                                break
                        except (json.JSONDecodeError, AttributeError):
                            pass
                except requests.exceptions.RequestException:
                    continue
    
    # Authentication Security Test Methods
    
    def _test_brute_force_protection(self, endpoint: str, findings: List[Dict[str, Any]]):
        """Test for brute force protection"""
        if not any(x in endpoint for x in ["/login", "/auth", "/signin"]):
            return
        
        try:
            # Try multiple login attempts with wrong credentials
            login_attempts = 10
            responses = []
            
            # Use a consistent username to trigger rate limiting
            credentials = {"username": "security_test_user", "password": "wrong_password"}
            
            for i in range(login_attempts):
                try:
                    response = self.session.post(
                        f"{self.target_url}{endpoint}",
                        json=credentials,
                        headers=self.headers,
                        timeout=5,
                        verify=False
                    )
                    responses.append(response.status_code)
                except requests.exceptions.RequestException:
                    break
            
            # Check if all requests were allowed (no rate limiting)
            if len(responses) == login_attempts and all(code not in [429, 403] for code in responses[-3:]):
                findings.append({
                    "title": "No Brute Force Protection Detected",
                    "endpoint": endpoint,
                    "description": f"Login endpoint allowed {login_attempts} consecutive failed attempts without rate limiting or blocking",
                    "severity": "high",
                    "attempts": login_attempts
                })
        except Exception:
            pass
    
    def _test_password_policy(self, endpoint: str, findings: List[Dict[str, Any]]):
        """Test for weak password policy"""
        if not any(x in endpoint for x in ["/register", "/signup", "/users/create"]):
            return
        
        try:
            weak_passwords = ["password", "123456", "qwerty", "letmein", "welcome"]
            
            for password in weak_passwords:
                try:
                    response = self.session.post(
                        f"{self.target_url}{endpoint}",
                        json={"username": "security_test_user", "email": "test@example.com", "password": password},
                        headers=self.headers,
                        timeout=5,
                        verify=False
                    )
                    
                    # If response is successful with weak password
                    if response.status_code in [200, 201]:
                        # Check if password was rejected
                        if "password" not in response.text.lower() and "weak" not in response.text.lower():
                            findings.append({
                                "title": "Weak Password Policy",
                                "endpoint": endpoint,
                                "description": f"Registration endpoint accepts weak passwords like '{password}'",
                                "severity": "medium",
                                "test_password": password
                            })
                            break
                except requests.exceptions.RequestException:
                    continue
        except Exception:
            pass
    
    def _test_account_lockout(self, endpoint: str, findings: List[Dict[str, Any]]):
        """Test for account lockout mechanism"""
        # This is similar to brute force protection, but focuses specifically on lockout
        if not any(x in endpoint for x in ["/login", "/auth", "/signin"]):
            return
        
        # Already covered by brute force protection test
        pass
    
    def _test_token_handling(self, endpoint: str, findings: List[Dict[str, Any]]):
        """Test for secure token handling"""
        if not any(x in endpoint for x in ["/login", "/auth", "/token"]):
            return
        
        try:
            # Test for token in URL
            response = self.session.get(
                f"{self.target_url}{endpoint}?token=test",
                headers=self.headers,
                timeout=5,
                verify=False
            )
            
            if response.status_code not in [404, 405]:
                findings.append({
                    "title": "Potential Insecure Token Handling",
                    "endpoint": endpoint,
                    "description": "Endpoint may accept authentication tokens via URL parameters, which is insecure",
                    "severity": "medium",
                    "status_code": response.status_code
                })
                
            # Check login response for secure cookie settings
            credentials = {"username": "security_test_user", "password": "test_password"}
            response = self.session.post(
                f"{self.target_url}{endpoint}",
                json=credentials,
                headers=self.headers,
                timeout=5,
                verify=False
            )
            
            if "set-cookie" in response.headers:
                cookie_header = response.headers["set-cookie"].lower()
                if "secure" not in cookie_header:
                    findings.append({
                        "title": "Insecure Cookie (Missing Secure Flag)",
                        "endpoint": endpoint,
                        "description": "Authentication cookies are missing the Secure flag",
                        "severity": "medium"
                    })
                
                if "httponly" not in cookie_header:
                    findings.append({
                        "title": "Insecure Cookie (Missing HttpOnly Flag)",
                        "endpoint": endpoint,
                        "description": "Authentication cookies are missing the HttpOnly flag",
                        "severity": "medium"
                    })
                
                if "samesite" not in cookie_header:
                    findings.append({
                        "title": "Insecure Cookie (Missing SameSite Attribute)",
                        "endpoint": endpoint,
                        "description": "Authentication cookies are missing the SameSite attribute",
                        "severity": "medium"
                    })
        except requests.exceptions.RequestException:
            pass
    
    def _test_mfa_support(self, endpoint: str, findings: List[Dict[str, Any]]):
        """Test for multi-factor authentication support"""
        if not any(x in endpoint for x in ["/login", "/auth", "/signin"]):
            return
        
        try:
            # Check login page for MFA indications
            response = self.session.get(
                f"{self.target_url}{endpoint}",
                headers=self.headers,
                timeout=5,
                verify=False
            )
            
            if response.status_code == 200 and "text/html" in response.headers.get("Content-Type", ""):
                response_text = response.text.lower()
                mfa_indicators = ["two-factor", "2fa", "two factor", "mfa", "authenticator", "verification code"]
                
                if not any(indicator in response_text for indicator in mfa_indicators):
                    findings.append({
                        "title": "Multi-Factor Authentication Not Detected",
                        "endpoint": endpoint,
                        "description": "No indication of multi-factor authentication support found",
                        "severity": "low"
                    })
                    
            # Also check if there's a separate MFA setup endpoint
            mfa_endpoints = ["/mfa", "/2fa", "/totp", "/security"]
            mfa_found = False
            
            for mfa_endpoint in mfa_endpoints:
                try:
                    response = self.session.head(
                        f"{self.target_url}{mfa_endpoint}",
                        headers=self.headers,
                        timeout=5,
                        verify=False
                    )
                    if response.status_code < 500:
                        mfa_found = True
                        break
                except requests.exceptions.RequestException:
                    continue
                    
            if not mfa_found:
                findings.append({
                    "title": "Multi-Factor Authentication Endpoints Not Found",
                    "endpoint": endpoint,
                    "description": "No dedicated MFA endpoints detected",
                    "severity": "low"
                })
                
        except requests.exceptions.RequestException:
            pass
    
    def _generate_report(self):
        """Generate the penetration test report"""
        # Save JSON report
        json_report_path = self.report_dir / f"pentest_{self.timestamp}.json"
        with open(json_report_path, "w") as f:
            json.dump(self.report_data, f, indent=2)
        
        # Generate markdown summary
        self._generate_markdown_summary()
    
    def _generate_markdown_summary(self):
        """Generate a markdown summary of the penetration test"""
        summary = self.report_data["summary"]
        vulns = summary["vulnerabilities"]
        
        md_report_path = self.report_dir / f"pentest_{self.timestamp}.md"
        with open(md_report_path, "w") as f:
            f.write("# Penetration Test Report\n\n")
            f.write(f"**Date:** {datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
            f.write(f"**Target:** {self.report_data['target']}\n\n")
            
            # Write summary
            f.write("## Summary\n\n")
            f.write(f"- **Endpoints Tested:** {summary['endpoints_tested']}\n")
            f.write(f"- **Vulnerable Endpoints:** {summary['vulnerable_endpoints']}\n")
            f.write("- **Vulnerabilities Found:**\n")
            f.write(f"  - Critical: {vulns['critical']}\n")
            f.write(f"  - High: {vulns['high']}\n")
            f.write(f"  - Medium: {vulns['medium']}\n")
            f.write(f"  - Low: {vulns['low']}\n")
            f.write(f"  - Info: {vulns['info']}\n\n")
            
            # Write high-priority issues
            if summary["security_issues"]:
                f.write("## High-Priority Issues\n\n")
                for issue in summary["security_issues"]:
                    f.write(f"- {issue}\n")
                f.write("\n")
            
            # Write API test results
            if "api_tests" in self.report_data:
                api_tests = self.report_data["api_tests"]
                f.write("## API Security Test Results\n\n")
                f.write(f"Tested {api_tests.get('endpoints_tested', 0)} API endpoints\n\n")
                
                if api_tests.get('findings', []):
                    f.write("| Endpoint | Vulnerability | Severity | Description |\n")
                    f.write("|----------|--------------|----------|-------------|\n")
                    for finding in api_tests['findings']:
                        f.write(f"| {finding['endpoint']} | {finding['title']} | {finding['severity'].upper()} | {finding['description']} |\n")
                else:
                    f.write("✅ No API vulnerabilities found\n")
                f.write("\n")
            
            # Write web test results
            if "web_tests" in self.report_data:
                web_tests = self.report_data["web_tests"]
                f.write("## Web Application Security Test Results\n\n")
                
                if web_tests.get('findings', []):
                    f.write("| Endpoint | Vulnerability | Severity | Description |\n")
                    f.write("|----------|--------------|----------|-------------|\n")
                    for finding in web_tests['findings']:
                        f.write(f"| {finding.get('endpoint', '/')} | {finding['title']} | {finding['severity'].upper()} | {finding['description']} |\n")
                else:
                    f.write("✅ No web application vulnerabilities found\n")
                f.write("\n")
            
            # Write auth test results
            if "auth_tests" in self.report_data:
                auth_tests = self.report_data["auth_tests"]
                f.write("## Authentication & Authorization Test Results\n\n")
                f.write(f"Tested {auth_tests.get('endpoints_tested', 0)} authentication endpoints\n\n")
                
                if auth_tests.get('findings', []):
                    f.write("| Endpoint | Vulnerability | Severity | Description |\n")
                    f.write("|----------|--------------|----------|-------------|\n")
                    for finding in auth_tests['findings']:
                        f.write(f"| {finding.get('endpoint', 'auth system')} | {finding['title']} | {finding['severity'].upper()} | {finding['description']} |\n")
                else:
                    f.write("✅ No authentication vulnerabilities found\n")
                f.write("\n")
            
            # Write recommendations
            f.write("## Recommendations\n\n")
            f.write("1. **Fix Critical and High Vulnerabilities Immediately**: Address the most severe issues as a priority.\n")
            f.write("2. **Implement API Security Controls**: Follow OWASP API Security Top 10 recommendations.\n")
            f.write("3. **Enhance Authentication**: Use strong password policies, MFA, and secure session management.\n")
            f.write("4. **Apply Input Validation**: Add server-side validation for all user inputs.\n")
            f.write("5. **Configure Security Headers**: Add proper HTTP security headers.\n")
            f.write("6. **Implement Rate Limiting**: Protect against brute force and DoS attacks.\n")
            f.write("7. **Regular Security Testing**: Schedule routine penetration tests.\n")
    
    def _print_summary(self):
        """Print a summary of the penetration test results"""
        summary = self.report_data["summary"]
        vulns = summary["vulnerabilities"]
        
        print("\nPenetration Test Summary:")
        print(f"- Endpoints Tested: {summary['endpoints_tested']}")
        print(f"- Vulnerable Endpoints: {summary['vulnerable_endpoints']}")
        print("- Vulnerabilities Found:")
        print(f"  - Critical: {vulns['critical']}")
        print(f"  - High: {vulns['high']}")
        print(f"  - Medium: {vulns['medium']}")
        print(f"  - Low: {vulns['low']}")
        print(f"  - Info: {vulns['info']}")
        
        if summary["security_issues"]:
            print("\nHigh-Priority Issues:")
            for issue in summary["security_issues"]:
                print(f"- {issue}")


def main():
    """Main entry point for the penetration testing tool"""
    parser = argparse.ArgumentParser(description="Penetration Testing Tool for GPlus Recycling App")
    parser.add_argument("--target", type=str, required=True,
                        help="Target URL (e.g. http://localhost:8000)")
    parser.add_argument("--scope", choices=["all", "api", "web", "auth"], default="all",
                        help="Scope of the penetration test")
    parser.add_argument("--report-dir", type=str, default=None,
                        help="Directory to save the test reports")
    parser.add_argument("--verbose", action="store_true",
                        help="Enable verbose output")
    
    args = parser.parse_args()
    
    # Set up report directory
    report_dir = Path(args.report_dir) if args.report_dir else REPORT_DIR
    
    # Run the tests
    pentest_tool = PenetrationTestTool(args.target, report_dir=report_dir, verbose=args.verbose)
    pentest_tool.run_pentest(scope=args.scope)


if __name__ == "__main__":
    main()